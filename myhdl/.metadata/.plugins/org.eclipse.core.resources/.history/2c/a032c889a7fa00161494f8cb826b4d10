from myhdl import *

ACTIVE_LOW, INACTIVE_HIGH = 0, 1

def Counter(count, enable, reset, n):

    """ Incrementer on enable.

    count -- output
    enable -- control input, increment when rising edge
    reset -- asynchronous reset input
    n -- counter max value

    """

    @always_seq(enable.posedge, reset=reset)
    def counterLogic():
        count.next = (count + 1) % n

    return counterLogic

def SpiControl(clock, data, width, dataReady, send, nextField, dataField):
    """ Splits the data into width bitfields and assigns them one after the other
    
    data -- input data
    width -- the data width in bits
    dataReady -- signal data is ready for transmission
    send -- toggle the transmission
    nextField -- which part should be send
    """
    
    
    @always_seq(clock.posedge)
    def spiLogic():
        if(dataReady):
            dataField.next = data[(nextField*width)-1:(nextField*(width-1))];
            send.next = 1;
        else:
            send.next = 0;
            
    return spiLogic()
    

from random import randrange

def testbench():
    count, enable, clock = [Signal(intbv(0)) for i in range(3)]
    reset = ResetSignal(0, active=ACTIVE_LOW, async=True)
    
    dataReady, send, nextField = [Signal(intbv(0)) for i in range(6)]

    data = Signal(intbv(9999))
    width = Signal(intbv(8))
    dataField = Signal(intbv(0,min=0,max=256))

    counter = Counter(count, enable, reset, n=4)
    spi = SpiControl(clock, data, width, dataReady, send, nextField, dataField)

    HALF_PERIOD = delay(10)

    @always(HALF_PERIOD)
    def clockGen():
        clock.next = not clock

    @instance
    def stimulus():
        reset.next = ACTIVE_LOW
        yield clock.negedge
        reset.next = INACTIVE_HIGH
        for i in range(12):
            enable.next = min(1, randrange(3))
            yield clock.negedge
        raise StopSimulation

    @instance
    def monitor():
        print "enable  count data dataReady send nextField dataField"
        yield reset.posedge
        while 1:
            yield clock.posedge
            yield delay(1)
            print "   %s      %s" % (enable, count)

    return clockGen, stimulus, counter, spi, monitor


tb = testbench()
Simulation(tb).run()
