from myhdl import *

ACTIVE_LOW, INACTIVE_HIGH = 0, 1

def Counter(count, enable, reset, n):

    """ Incrementer on enable.

    count -- output
    enable -- control input, increment when rising edge
    reset -- asynchronous reset input
    n -- counter max value

    """

    @always_seq(enable.posedge, reset=reset)
    def incLogic():
        count.next = (count + 1) % n

    return incLogic

def Spi_control(data, width, dataReady, send, nextField):
    """ Splits the data into width bitfields and assigns them one after the other
    
    data -- input data
    width -- the data width in bits
    dataReady -- signal data is ready for transmission
    send -- toggle the transmission
    nextField -- signal data has been transmitted and next field can be send
    """
    
    

from random import randrange

def testbench():
    count, enable, clock = [Signal(intbv(0)) for i in range(3)]
    reset = ResetSignal(0, active=ACTIVE_LOW, async=True)

    counter = Counter(count, enable, reset, n=4)

    HALF_PERIOD = delay(10)

    @always(HALF_PERIOD)
    def clockGen():
        clock.next = not clock

    @instance
    def stimulus():
        reset.next = ACTIVE_LOW
        yield clock.negedge
        reset.next = INACTIVE_HIGH
        for i in range(12):
            enable.next = min(1, randrange(3))
            yield clock.negedge
        raise StopSimulation

    @instance
    def monitor():
        print "enable  count"
        yield reset.posedge
        while 1:
            yield clock.posedge
            yield delay(1)
            print "   %s      %s" % (enable, count)

    return clockGen, stimulus, counter, monitor


tb = testbench()
Simulation(tb).run()
